<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Kitten Quest â€“ Valley of Light</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #7ec8ff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    user-select: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    background: #7ec8ff;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });

  // Resolution
  let W = 1280, H = 720;
  function resize() {
    W = Math.floor(window.innerWidth / 2) * 2;
    H = Math.floor(window.innerHeight / 2) * 2;
    canvas.width = W;
    canvas.height = H;
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  resize();

  // Utils
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now() / 1000;

  // Constants
  const TILE = 24;
  const GRAVITY = 52;
  const FRICTION = 0.88;
  const LEVEL_LENGTH = 7200; // width of the single handcrafted level

  // Game state
  const STATE = { RUN: 0, WIN: 1, OVER: 2 };
  let gameState = STATE.RUN;
  let startTime = now();
  let endTime = null;

  // Input
  const keys = new Set();
  const justPressed = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.key.toLowerCase());
    justPressed.add(e.key.toLowerCase());
    startAudio();
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));
  window.addEventListener('mousedown', () => startAudio(), { passive: true });
  window.addEventListener('touchstart', () => startAudio(), { passive: true });

  // Camera
  let camX = 0, camY = 0;
  let targetCamX = 0, targetCamY = 0;

  // Player
  const player = {
    x: 120, y: 0,
    w: TILE * 1.8, h: TILE * 1.8,
    vx: 0, vy: 0,
    speed: 140,
    onGround: false,
    canDouble: true,
    coyoteTime: 0,
    jumpBuffer: 0,
    facing: 1,
    animTime: 0,
    invuln: 0,
    lives: 3,
    score: 0,
  };

  // World helpers
  const groundY = () => Math.floor(H - TILE * 3);
  const platforms = []; // {x,y,w,h,type}
  const enemies = [];   // {x,y,w,h,dir,minX,maxX,speed}
  const coins = [];     // {x,y,w,h,phase}
  const particles = []; // ambient + hit/collect

  // Goal
  const goal = { x: LEVEL_LENGTH - 280, y: groundY() - TILE * 4, w: 220, h: TILE * 4 };

  // Parallax layers
  const clouds = [];
  const mountains = [];
  const farHills = [];
  const nearHills = [];
  const trees = [];
  const fireflies = []; // ambient particles
  const petals = [];    // drifting petals near goal

  // Audio
  let ac = null, musicNode = null, sfxGain = null;
  function startAudio() {
    if (ac) return;
    try {
      ac = new (window.AudioContext || window.webkitAudioContext)();
      sfxGain = ac.createGain();
      sfxGain.gain.value = 0.15;
      sfxGain.connect(ac.destination);
      startMusic();
    } catch {}
  }
  function startMusic() {
    if (!ac || musicNode) return;
    const tempo = 122;
    const beat = 60 / tempo;
    const seq = [0, 4, 7, 12, 7, 4, 0, 2, 5, 9, 12, 9, 5, 2, 0, -1];
    const baseFreq = 261.63; // C4
    const pad = ac.createOscillator();
    const padGain = ac.createGain();
    padGain.gain.value = 0.03;
    pad.type = 'triangle';
    pad.connect(padGain);
    padGain.connect(ac.destination);
    pad.start();

    const lead = ac.createOscillator();
    const leadGain = ac.createGain();
    leadGain.gain.value = 0.06;
    lead.type = 'square';
    lead.connect(leadGain);
    leadGain.connect(ac.destination);
    lead.start();

    let t0 = ac.currentTime;
    const schedule = () => {
      for (let i = 0; i < 32; i++) {
        const step = seq[i % seq.length];
        const freq = step < 0 ? 0 : baseFreq * Math.pow(2, step / 12);
        const t = t0 + i * beat * 0.5;
        if (freq > 0) {
          lead.frequency.setValueAtTime(freq, t);
          leadGain.gain.setValueAtTime(0.001, t);
          leadGain.gain.linearRampToValueAtTime(0.07, t + 0.02);
          leadGain.gain.linearRampToValueAtTime(0.05, t + beat * 0.45);
          pad.frequency.setValueAtTime(freq / 2, t);
        } else {
          leadGain.gain.setValueAtTime(0.0, t);
        }
      }
      t0 += 32 * beat * 0.5;
      musicNode = lead;
      setTimeout(schedule, 1200);
    };
    schedule();
  }
  function sfx({ freq = 440, type = 'square', time = 0.08, volume = 0.18 }) {
    if (!ac || !sfxGain) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = volume;
    o.connect(g);
    g.connect(sfxGain);
    const t = ac.currentTime;
    g.gain.setValueAtTime(volume, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + time);
    o.start(t);
    o.stop(t + time + 0.02);
  }
  const sfxJump = () => sfx({ freq: 640, type: 'square', time: 0.12, volume: 0.22 });
  const sfxDouble = () => sfx({ freq: 880, type: 'triangle', time: 0.1, volume: 0.18 });
  const sfxCoin = () => sfx({ freq: 1200, type: 'square', time: 0.07, volume: 0.24 });
  const sfxHit  = () => sfx({ freq: 180, type: 'sawtooth', time: 0.18, volume: 0.26 });
  const sfxWin  = () => sfx({ freq: 720, type: 'square', time: 0.45, volume: 0.3 });

  // Sprites
  const kittenImg = new Image(); kittenImg.src = 'kitten.png';
  const puppyImg  = new Image(); puppyImg.src  = 'puppy.png';

  // Ambient visuals
  function initParallax() {
    clouds.length = mountains.length = farHills.length = nearHills.length = trees.length = 0;
    fireflies.length = petals.length = 0;

    // Mountains span the whole level
    for (let x = -W; x < LEVEL_LENGTH + W; x += randi(240, 420)) {
      mountains.push({ x, w: randi(220, 380), h: randi(H * 0.25, H * 0.44) });
    }
    // Far and near hills
    for (let x = -W; x < LEVEL_LENGTH + W; x += randi(180, 300)) {
      farHills.push({ x, w: randi(180, 300), h: randi(90, 160) });
    }
    for (let x = -W; x < LEVEL_LENGTH + W; x += randi(160, 240)) {
      nearHills.push({ x, w: randi(160, 240), h: randi(70, 120) });
    }
    // Clouds
    for (let i = 0; i < 50; i++) {
      clouds.push({ x: rand(-W, LEVEL_LENGTH + W), y: rand(20, H * 0.45), w: rand(80, 160), h: rand(20, 40), s: rand(6, 14) });
    }
    // Trees
    for (let x = -W; x < LEVEL_LENGTH + W; x += randi(80, 140)) {
      trees.push({ x: x + rand(-10, 10), h: rand(46, 100) });
    }
    // Fireflies over grass
    for (let i = 0; i < 120; i++) {
      fireflies.push({ x: rand(0, LEVEL_LENGTH), y: rand(groundY() - 120, groundY() - 20), a: rand(0, Math.PI * 2), r: rand(1, 2) });
    }
    // Petals near goal
    for (let i = 0; i < 40; i++) {
      petals.push({ x: goal.x - 200 + rand(0, 500), y: groundY() - TILE * 9 + rand(0, 120), t: rand(0, 6.28) });
    }
  }

  // Level building
  function buildLevel() {
    platforms.length = enemies.length = coins.length = particles.length = 0;

    // Ground: continuous carpet
    for (let x = -W; x <= LEVEL_LENGTH + W; x += TILE * 3) {
      platforms.push({ x, y: groundY(), w: TILE * 3, h: TILE, type: 'ground' });
    }

    // Scenic setpieces: lakes with reflections
    lakes.push({ x: 1200, w: 480 });
    lakes.push({ x: 3400, w: 360 });

    // Hand-authored floating platforms, reachable flow
    const pf = (x, yTiles, wTiles=4) => platforms.push({ x, y: groundY() - yTiles * TILE, w: wTiles * TILE, h: TILE, type: 'float' });
    // Early onboarding
    pf(420, 6, 4);
    pf(650, 5, 3);
    pf(880, 7, 4);
    // Over the first lake
    pf(1200, 8, 4);
    pf(1350, 7, 3);
    pf(1520, 6, 5);
    // Mid-section variety
    pf(1900, 7, 4);
    pf(2050, 9, 3);
    pf(2200, 6, 4);
    pf(2350, 7, 3);
    // Elevated route
    pf(2700, 8, 5);
    pf(2880, 7, 3);
    pf(3040, 6, 4);
    // Over second lake
    pf(3400, 7, 5);
    pf(3580, 8, 4);
    pf(3770, 7, 4);
    // Finale ascent toward goal
    pf(4100, 7, 4);
    pf(4280, 8, 4);
    pf(4460, 7, 4);
    pf(4650, 6, 5);
    pf(4850, 7, 4);
    pf(5050, 6, 4);
    pf(5250, 7, 5);
    pf(5450, 6, 4);
    pf(5650, 5, 5);

    // Coins (glowing fish): ground lines and arcs above platforms
    const fishLine = (x, n, gap=0.9) => {
      for (let i=0;i<n;i++) coins.push({ x: x + i * TILE * gap, y: groundY() - TILE * 1.6, w: TILE * 0.7, h: TILE * 0.7, phase: rand(0, 6.28) });
    };
    const fishArc = (x, yT, n, amp=0.5) => {
      const y = groundY() - yT * TILE;
      for (let i=0;i<n;i++) {
        coins.push({ x: x + i * TILE * 0.9, y: y + Math.sin(i) * TILE * amp, w: TILE * 0.7, h: TILE * 0.7, phase: rand(0, 6.28) });
      }
    };

    fishLine(240, 7);
    fishArc(420, 7.6, 5);
    fishArc(1200, 9.2, 5);
    fishArc(1500, 6.8, 6);
    fishLine(1760, 6);
    fishArc(2050, 9.6, 5);
    fishArc(2200, 7.2, 6);
    fishLine(2600, 7);
    fishArc(2880, 7.6, 6);
    fishArc(3040, 6.6, 6);
    fishLine(3300, 8);
    fishArc(3400, 8.8, 6);
    fishArc(3580, 9.6, 5);
    fishLine(3900, 7);
    fishArc(4100, 8.2, 6);
    fishArc(4650, 6.6, 6);
    fishLine(4950, 8);
    fishArc(5250, 8.2, 6);
    fishLine(5600, 7);

    // Puppies: mix of ground patrols and platform patrols
    const pupGround = (x, span=TILE*4) => {
      const w = TILE*1.8, h = TILE*1.8;
      const minX = x - span/2, maxX = x + span/2 - w;
      enemies.push({ x: clamp(x, minX, maxX), y: groundY() - h, w, h, dir: Math.random()<0.5?-1:1, minX, maxX, speed: rand(30, 50) });
    };
    const pupOnPlat = (px, pyTiles, wTiles=4) => {
      const w = TILE*1.8, h = TILE*1.8;
      const px0 = px + TILE*0.2, px1 = px + wTiles*TILE - TILE*0.2 - w;
      enemies.push({ x: rand(px0, px1), y: groundY() - pyTiles*TILE - h, w, h, dir: Math.random()<0.5?-1:1, minX: px0, maxX: px1, speed: rand(30, 50) });
    };

    pupGround(700, TILE*8);
    pupOnPlat(1200, 8, 4);
    pupOnPlat(1520, 6, 5);
    pupGround(1800, TILE*10);
    pupOnPlat(2050, 9, 3);
    pupOnPlat(2200, 6, 4);
    pupGround(2500, TILE*8);
    pupOnPlat(2700, 8, 5);
    pupOnPlat(3040, 6, 4);
    pupGround(3300, TILE*10);
    pupOnPlat(3400, 7, 5);
    pupOnPlat(3770, 7, 4);
    pupGround(4050, TILE*10);
    pupOnPlat(4280, 8, 4);
    pupOnPlat(4650, 6, 5);
    pupGround(4950, TILE*10);
    pupOnPlat(5250, 7, 5);
    pupGround(5600, TILE*10);
  }

  // Decorative lakes
  const lakes = []; // {x,w}

  // Physics helpers
  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Effects
  const shake = { time: 0, intensity: 0 };
  function screenShake(i=6, t=0.15) { shake.time = t; shake.intensity = i; }
  function spawnSparkle(x, y, color = '#ffd54a') {
    for (let i = 0; i < 10; i++) {
      particles.push({ x, y, vx: rand(-40, 40), vy: rand(-70, -20), life: rand(0.3, 0.6), color });
    }
  }

  // Hearts
  function drawHeart(x, y, size, color) {
    ctx.fillStyle = color;
    const s = size / 6;
    const px = (dx, dy, w, h) => ctx.fillRect(Math.round(x + dx * s), Math.round(y + dy * s), Math.round(w * s), Math.round(h * s));
    px(1,0, 1,2); px(2,0, 1,2); px(3,0, 1,2); px(4,0, 1,2);
    px(0,1, 2,1); px(5,1, 2,1);
    px(0,2, 1,1); px(6,2, 1,1);
    px(1,2, 5,1);
    px(1,3, 5,1);
    px(2,4, 3,1);
    px(3,5, 1,1);
  }

  // Main loop
  let prev = now();
  function loop() {
    const t = now();
    let dt = t - prev;
    if (dt > 0.033) dt = 0.033;
    prev = t;

    update(dt);
    draw();

    justPressed.clear();
    requestAnimationFrame(loop);
  }

  // Reset
  function resetGame() {
    player.x = 120; player.y = groundY() - player.h - 2;
    player.vx = 0; player.vy = 0; player.onGround = false; player.canDouble = true;
    player.coyoteTime = 0; player.jumpBuffer = 0; player.facing = 1; player.animTime = 0;
    player.invuln = 0; player.lives = 3; player.score = 0;
    camX = 0; targetCamX = 0; camY = 0; targetCamY = 0;
    startTime = now(); endTime = null; gameState = STATE.RUN;
    lakes.length = 0;
    initParallax();
    buildLevel();
  }

  function handleInput(dt) {
    const left = keys.has('arrowleft') || keys.has('a');
    const right = keys.has('arrowright') || keys.has('d');
    const jumpKey = keys.has(' ') || keys.has('space');

    const accel = 420;
    if (left) { player.vx -= accel * dt; player.facing = -1; }
    if (right) { player.vx += accel * dt; player.facing = 1; }
    player.vx = clamp(player.vx, -player.speed, player.speed * 1.4);

    // Jump buffer & coyote time
    if (justPressed.has(' ') || justPressed.has('space')) player.jumpBuffer = 0.16;
    if (player.onGround) player.coyoteTime = 0.12; else player.coyoteTime -= dt;
    if (player.jumpBuffer > 0) player.jumpBuffer -= dt;

    const wantJump = player.jumpBuffer > 0 && (player.onGround || player.coyoteTime > 0 || player.canDouble);
    if (wantJump) {
      if (player.onGround || player.coyoteTime > 0) {
        player.vy = -Math.sqrt(2 * GRAVITY * (TILE * 3.2));
        player.onGround = false;
        player.coyoteTime = 0;
        player.jumpBuffer = 0;
        player.canDouble = true;
        sfxJump();
      } else if (player.canDouble) {
        player.vy = -Math.sqrt(2 * GRAVITY * (TILE * 2.6));
        player.canDouble = false;
        player.jumpBuffer = 0;
        spawnSparkle(player.x + player.w/2, player.y + player.h/2, '#9ad1ff');
        sfxDouble();
      }
    }
    if (!jumpKey && player.vy < 0) player.vy *= 0.9; // variable-height jump
  }

  function update(dt) {
    if (gameState === STATE.WIN || gameState === STATE.OVER) {
      if (justPressed.has('enter')) resetGame();
      return;
    }

    handleInput(dt);

    // Physics
    player.vy += GRAVITY * dt;
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.vx *= player.onGround ? FRICTION : 0.99;
    player.animTime += dt;
    if (player.invuln > 0) player.invuln -= dt;

    // Collisions with platforms near the player
    player.onGround = false;
    const near = platforms.filter(p => p.x + p.w > player.x - TILE*2 && p.x < player.x + player.w + TILE*2 && p.y < player.y + player.h + TILE*3 && p.y > player.y - TILE*10);

    // Vertical
    for (const p of near) {
      if (rectsOverlap(player, p)) {
        const prevY = player.y - player.vy * dt;
        if (prevY + player.h <= p.y) {
          player.y = p.y - player.h; player.vy = 0; player.onGround = true;
        } else if (prevY >= p.y + p.h) {
          player.y = p.y + p.h; if (player.vy < 0) player.vy = 0;
        }
      }
    }
    // Horizontal
    for (const p of near) {
      if (rectsOverlap(player, p)) {
        const prevX = player.x - player.vx * dt;
        if (prevX + player.w <= p.x) {
          player.x = p.x - player.w; player.vx = 0;
        } else if (prevX >= p.x + p.w) {
          player.x = p.x + p.w; player.vx = 0;
        }
      }
    }

    // Clamp to ground band (no falling off-screen)
    if (player.y + player.h > groundY()) { player.y = groundY() - player.h; player.vy = 0; player.onGround = true; }
    player.y = clamp(player.y, 0, groundY() - player.h);

    // Camera follow & clamp to level bounds
    targetCamX = clamp(player.x - W * 0.35, 0, LEVEL_LENGTH - W);
    camX += (targetCamX - camX) * 0.1;
    camY += (targetCamY - camY) * 0.1;

    // Enemies patrol
    for (const e of enemies) {
      e.x += e.dir * e.speed * dt;
      if (e.x < e.minX) { e.x = e.minX; e.dir = 1; }
      if (e.x > e.maxX) { e.x = e.maxX; e.dir = -1; }
    }

    // Coins bob
    for (const c of coins) {
      c.phase += dt;
      c.y += Math.sin(c.phase * 2) * dt * 10;
    }

    // Ambient particles
    for (const f of fireflies) {
      f.a += dt * rand(0.4, 0.8);
      f.x += Math.cos(f.a) * 8 * dt;
      f.y += Math.sin(f.a * 0.8) * 8 * dt;
      // keep within grass band
      if (f.x < 0) f.x = 0; if (f.x > LEVEL_LENGTH) f.x = LEVEL_LENGTH;
      f.y = clamp(f.y, groundY() - 140, groundY() - 18);
    }
    for (const p of petals) {
      p.t += dt;
      p.x += Math.cos(p.t * 1.3) * 14 * dt + 14 * dt;
      p.y += Math.sin(p.t * 1.1) * 8 * dt + 10 * dt;
      if (p.x > goal.x + 400) { p.x = goal.x - 200; p.y = groundY() - TILE * 9 + rand(0, 120); p.t = rand(0, 6.28); }
    }

    // Particles update
    for (let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.vy += GRAVITY * 0.9 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    // Collect coins
    for (let i=coins.length-1; i>=0; i--) {
      if (rectsOverlap(player, coins[i])) {
        const c = coins.splice(i,1)[0];
        player.score += 1;
        spawnSparkle(c.x + c.w/2, c.y + c.h/2, '#fff07a');
        sfxCoin();
      }
    }

    // Enemy collision
    if (player.invuln <= 0) {
      for (const e of enemies) {
        if (rectsOverlap(player, e)) {
          player.lives -= 1;
          player.invuln = 1.2;
          screenShake(8, 0.22);
          spawnSparkle(player.x + player.w/2, player.y + player.h/2, '#ff7b7b');
          sfxHit();
          break;
        }
      }
    }
    if (player.lives <= 0) gameState = STATE.OVER;

    // Goal reached
    if (rectsOverlap(player, goal)) {
      gameState = STATE.WWIN; // guard for single frame
      setTimeout(() => {
        if (gameState !== STATE.RUN) {
          gameState = STATE.WIN;
          endTime = now();
          sfxWin();
        }
      }, 80);
    }

    if (shake.time > 0) shake.time -= dt;
  }

  function draw() {
    // Shake
    const sx = shake.time > 0 ? (Math.random() - 0.5) * shake.intensity : 0;
    const sy = shake.time > 0 ? (Math.random() - 0.5) * shake.intensity : 0;

    // Background sky gradient with sun
    const sky = ctx.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, '#b2e6ff');
    sky.addColorStop(0.5, '#d8f3ff');
    sky.addColorStop(1, '#f4fbff');
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, W, H);

    // Sun and godrays
    const sunX = clamp(goal.x - camX - 200, -200, W + 200);
    const sunY = 120;
    drawSun(sunX + sx, sunY + sy);

    // Far mountains
    for (const m of mountains) {
      const x = Math.round(m.x - camX * 0.12 + sx);
      const y = Math.round(groundY() - m.h + sy);
      ctx.fillStyle = '#9ab9cf';
      ctx.beginPath();
      ctx.moveTo(x, groundY() + 100);
      ctx.lineTo(x + m.w/2, y);
      ctx.lineTo(x + m.w, groundY() + 100);
      ctx.closePath();
      ctx.fill();
    }

    // Far hills
    ctx.fillStyle = '#a6d1b7';
    for (const h of farHills) {
      const x = Math.round(h.x - camX * 0.18 + sx);
      const y = Math.round(groundY() - h.h * 0.7 + sy);
      ctx.beginPath();
      ctx.ellipse(x + h.w/2, y + h.h/2, h.w/2, h.h/2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Clouds
    for (const c of clouds) {
      c.x -= c.s * 0.02; // subtle drift
      const x = Math.round(c.x - camX * 0.22 + sx);
      const y = Math.round(c.y + sy);
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      roundedRect(x, y, c.w, c.h, 14); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      roundedRect(x + 28, y - 8, c.w * 0.6, c.h * 0.9, 12); ctx.fill();
      if (c.x + c.w < -200) c.x = LEVEL_LENGTH + 200;
    }

    // Near hills
    ctx.fillStyle = '#78c48f';
    for (const h of nearHills) {
      const x = Math.round(h.x - camX * 0.35 + sx);
      const y = Math.round(groundY() - h.h * 0.5 + sy);
      ctx.beginPath();
      ctx.ellipse(x + h.w/2, y + h.h/2, h.w/2, h.h/2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Trees
    for (const tr of trees) {
      const x = Math.round(tr.x - camX * 0.6 + sx);
      const y = groundY() + sy;
      ctx.fillStyle = '#3a6f39';
      ctx.fillRect(x, y - tr.h, 10, tr.h);
      ctx.fillStyle = '#51a356';
      ctx.beginPath();
      ctx.arc(x + 5, y - tr.h, tr.h * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }

    // Lakes with reflections
    for (const lk of lakes) drawLake(lk);

    // Platforms and ground
    for (const p of platforms) {
      const x = Math.round(p.x - camX + sx);
      const y = Math.round(p.y + sy);
      if (p.type === 'ground') {
        ctx.fillStyle = '#7a5230'; ctx.fillRect(x, y, p.w, p.h);
        ctx.fillStyle = '#6b451d'; ctx.fillRect(x, y + p.h - 6, p.w, 6);
        ctx.fillStyle = '#6ed26a'; ctx.fillRect(x, y - 6, p.w, 6);
      } else {
        ctx.fillStyle = '#7a5230'; ctx.fillRect(x, y, p.w, p.h);
        ctx.fillStyle = '#6ed26a'; ctx.fillRect(x, y - 5, p.w, 5);
        ctx.fillStyle = '#5e3c23';
        for (let i = 0; i < Math.floor(p.w / 18); i++) ctx.fillRect(x + 6 + i * 18, y + p.h - 4, 4, 4);
      }
    }

    // Coins (glow)
    for (const c of coins) {
      const x = Math.round(c.x - camX + sx);
      const y = Math.round(c.y + sy);
      // glow
      radialGlow(x + c.w/2, y + c.h/2, 18, 'rgba(255,240,120,0.25)');
      ctx.fillStyle = '#fff07a';
      roundedRect(x, y, c.w, c.h, 6); ctx.fill();
      ctx.fillStyle = '#ffd54a';
      ctx.beginPath();
      ctx.moveTo(x + c.w, y + c.h/2);
      ctx.lineTo(x + c.w + 8, y + c.h/4);
      ctx.lineTo(x + c.w + 8, y + c.h * 0.75);
      ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#5e4c1a';
      ctx.fillRect(Math.round(x + c.w * 0.2), Math.round(y + c.h * 0.35), 3, 3);
    }

    // Enemies (puppy sprites)
    for (const e of enemies) {
      const x = Math.round(e.x - camX + sx);
      const y = Math.round(e.y + sy);
      drawPuppy(x, y, e.w, e.h, e.dir);
    }

    // Player (kitten sprite)
    drawPlayer(player, sx, sy);

    // Ambient particles foreground
    for (const f of fireflies) {
      const x = Math.round(f.x - camX + sx), y = Math.round(f.y + sy);
      radialGlow(x, y, 10, 'rgba(255,255,180,0.22)');
      ctx.fillStyle = '#fff9b0';
      ctx.fillRect(x, y, f.r, f.r);
    }
    for (const p of petals) {
      const x = Math.round(p.x - camX + sx), y = Math.round(p.y + sy);
      ctx.fillStyle = 'rgba(255,192,203,0.85)';
      roundedRect(x, y, 6, 3, 2); ctx.fill();
    }

    // Foreground flowers
    drawFlowers();

    // Goal portal/shrine
    drawGoal();

    // Vignette for cinematic look
    vignette();

    // UI
    drawUI();

    // Win/Over overlays
    if (gameState === STATE.WIN) drawWin();
    if (gameState === STATE.OVER) drawGameOver();
  }

  function drawSun(x, y) {
    // soft glow
    radialGlow(x, y, 160, 'rgba(255, 245, 200, 0.22)');
    radialGlow(x, y, 90, 'rgba(255, 250, 220, 0.28)');
    ctx.fillStyle = '#fff7cc';
    ctx.beginPath(); ctx.arc(x, y, 28, 0, Math.PI*2); ctx.fill();
    // subtle rays
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((now() * 0.1) % (Math.PI*2));
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = '#fff6cc';
    for (let i=0;i<12;i++) {
      ctx.rotate(Math.PI / 6);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(180, 10);
      ctx.lineTo(180, -10);
      ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  function drawLake(lk) {
    const x = Math.round(lk.x - camX), y = groundY();
    const w = lk.w, h = 60;
    // water
    const grad = ctx.createLinearGradient(0, y, 0, y + h);
    grad.addColorStop(0, 'rgba(120,200,255,0.6)');
    grad.addColorStop(1, 'rgba(60,140,220,0.6)');
    ctx.fillStyle = grad;
    ctx.fillRect(x, y, w, h);
    // simple reflection ripples
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#ffffff';
    for (let i=0;i<6;i++) {
      ctx.fillRect(x + 10 + i* (w/6), y + 10 + Math.sin(now()*2 + i)*3, w/12, 2);
    }
    ctx.globalAlpha = 1;
  }

  function radialGlow(x, y, r, color) {
    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
    g.addColorStop(0, color);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  }

  function drawFlowers() {
    // little tufts on the ground
    for (let gx = Math.floor(camX/24)*24 - 48; gx < camX + W + 48; gx += 24) {
      const x = Math.round(gx - camX), y = groundY() - 8;
      // stems
      ctx.fillStyle = '#3a8f3a';
      ctx.fillRect(x+8, y-6, 2, 6);
      // blooms
      ctx.fillStyle = ['#ffb3c1','#ffd166','#9bf6ff','#baffc9'][((gx/24)|0)%4];
      ctx.fillRect(x+6, y-8, 2, 2);
      ctx.fillRect(x+10, y-8, 2, 2);
    }
  }

  function drawGoal() {
    const x = Math.round(goal.x - camX), y = goal.y, w = goal.w, h = goal.h;
    // platform pad
    ctx.fillStyle = '#cdb79e';
    roundedRect(x + 30, groundY() - 8, w - 60, 8, 4); ctx.fill();

    // shrine columns
    ctx.fillStyle = '#f7e7c4';
    roundedRect(x + 30, y, 20, h, 6); ctx.fill();
    roundedRect(x + w - 50, y, 20, h, 6); ctx.fill();

    // portal oval
    const cx = x + w/2, cy = y + h/2, rx = 60, ry = h * 0.6;
    const glowC = { x: cx, y: cy - 6 };
    radialGlow(glowC.x, glowC.y, 120, 'rgba(180, 240, 255, 0.18)');
    radialGlow(glowC.x, glowC.y, 80, 'rgba(160, 230, 255, 0.22)');
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(1, ry/rx);
    ctx.fillStyle = '#b8f1ff';
    ctx.beginPath(); ctx.arc(0, 0, rx, 0, Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath(); ctx.arc(-20, -10, 18, 0, Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();

    // floating motes near portal
    for (let i=0;i<6;i++) {
      const px = cx + Math.sin(now()*2 + i)*30;
      const py = cy - 20 + Math.cos(now()*2.2 + i)*18;
      radialGlow(px - camX + goal.x - goal.x, py, 16, 'rgba(200,255,255,0.3)');
    }
  }

  function vignette() {
    const g = ctx.createRadialGradient(W/2, H*0.6, Math.min(W,H)*0.2, W/2, H*0.6, Math.max(W,H)*0.7);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.22)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);
  }

  function drawPlayer(pl, sx, sy) {
    const x = Math.round(pl.x - camX + sx);
    const y = Math.round(pl.y + sy);
    const w = Math.round(pl.w);
    const h = Math.round(pl.h);
    const bob = (Math.abs(pl.vx) > 8 && pl.onGround) ? Math.sin(pl.animTime * 16) * 2 : 0;
    const blink = pl.invuln > 0 && Math.floor(pl.animTime * 20) % 2 === 0;
    if (blink) return;
    ctx.save();
    if (pl.facing === -1) {
      ctx.translate(x + w, y + bob);
      ctx.scale(-1, 1);
      ctx.drawImage(kittenImg, 0, 0, w, h);
    } else {
      ctx.drawImage(kittenImg, x, y + bob, w, h);
    }
    ctx.restore();
  }

  function drawPuppy(x, y, w, h, dir) {
    ctx.save();
    if (dir === -1) {
      ctx.translate(x + w, y);
      ctx.scale(-1, 1);
      ctx.drawImage(puppyImg, 0, 0, w, h);
    } else {
      ctx.drawImage(puppyImg, x, y, w, h);
    }
    ctx.restore();
  }

  function drawUI() {
    // Score
    ctx.fillStyle = '#073b4c';
    ctx.fillRect(12, 12, 180, 46);
    ctx.fillStyle = '#118ab2';
    ctx.fillRect(12, 12, 180, 6);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(`Score: ${player.score}`, 22, 25);

    // Lives
    const heartSize = 22, pad = 8;
    const livesW = player.lives * (heartSize + pad) + 12;
    const x0 = W - livesW - 12;
    ctx.fillStyle = '#073b4c';
    ctx.fillRect(x0, 12, livesW, 46);
    ctx.fillStyle = '#ef476f';
    ctx.fillRect(x0, 12, livesW, 6);
    for (let i = 0; i < player.lives; i++) {
      drawHeart(x0 + 8 + i * (heartSize + pad), 22, heartSize, '#ff6b81');
    }

    // Progress bar
    const prog = clamp(player.x / (LEVEL_LENGTH - 200), 0, 1);
    const pbW = Math.min(480, W - 200);
    const pbX = Math.round(W/2 - pbW/2);
    const pbY = 16;
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    roundedRect(pbX, pbY, pbW, 10, 5); ctx.fill();
    ctx.fillStyle = '#4cc9f0';
    roundedRect(pbX, pbY, pbW * prog, 10, 5); ctx.fill();

    // Controls hint (fade out)
    const t = now() - startTime;
    if (t < 7 && gameState === STATE.RUN && player.score < 3) {
      ctx.globalAlpha = 1 - Math.min(1, (t - 1.5) / 5.5);
      ctx.fillStyle = '#032b43';
      ctx.fillRect(16, H - 64, 520, 48);
      ctx.fillStyle = '#a8dadc';
      ctx.font = '16px monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText('Move: Arrow keys / WASD   Jump: Space (Double Jump)   Restart: Enter', 26, H - 40);
      ctx.globalAlpha = 1;
    }
  }

  function drawWin() {
    overlayDim(0.35);
    const panelW = 460, panelH = 260;
    const px = Math.round(W/2 - panelW/2), py = Math.round(H/2 - panelH/2);
    ctx.fillStyle = '#1d3557';
    roundedRect(px, py, panelW, panelH, 16); ctx.fill();
    ctx.fillStyle = '#a8dadc';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Level Complete!', px + panelW/2, py + 20);

    const timeTaken = (endTime ? endTime - startTime : 0).toFixed(2);
    ctx.font = '20px monospace';
    ctx.fillStyle = '#f1faee';
    ctx.fillText(`Score: ${player.score}`, px + panelW/2, py + 78);
    ctx.fillText(`Time: ${timeTaken}s`, px + panelW/2, py + 108);

    // Restart button
    const bw = 200, bh = 50;
    const bx = px + panelW/2 - bw/2, by = py + panelH - bh - 28;
    ctx.fillStyle = '#2a9d8f';
    roundedRect(bx, by, bw, bh, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('Play Again (Enter)', bx + bw/2, by + 14);

    canvas.onclick = (ev) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);
      const my = (ev.clientY - rect.top) * (canvas.height / rect.height);
      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
        canvas.onclick = null;
        resetGame();
      }
    };
  }

  function drawGameOver() {
    overlayDim(0.35);
    const panelW = 420, panelH = 240;
    const px = Math.round(W/2 - panelW/2), py = Math.round(H/2 - panelH/2);
    ctx.fillStyle = '#1d3557';
    roundedRect(px, py, panelW, panelH, 16); ctx.fill();
    ctx.fillStyle = '#a8dadc';
    ctx.font = 'bold 36px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('Game Over', px + panelW/2, py + 20);
    ctx.font = '20px monospace';
    ctx.fillStyle = '#f1faee';
    ctx.fillText(`Score: ${player.score}`, px + panelW/2, py + 78);
    const bw = 200, bh = 50;
    const bx = px + panelW/2 - bw/2, by = py + panelH - bh - 28;
    ctx.fillStyle = '#e63946';
    roundedRect(bx, by, bw, bh, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('Retry (Enter)', bx + bw/2, by + 14);

    canvas.onclick = (ev) => {
      const rect = canvas.getBoundingClientRect();
      const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);
      const my = (ev.clientY - rect.top) * (canvas.height / rect.height);
      if (mx >= bx && mx <= bx + bw && my >= by && my <= by + bh) {
        canvas.onclick = null;
        resetGame();
      }
    };
  }

  function overlayDim(a=0.35) {
    ctx.fillStyle = `rgba(0,0,0,${a})`;
    ctx.fillRect(0, 0, W, H);
  }

  function roundedRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  // Boot
  resetGame();
  loop();
})();
</script>
</body>
</html>
